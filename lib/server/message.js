// Generated by CoffeeScript 1.3.3
(function() {
  var Message, redis, sanitizer;

  redis = require('redis').createClient(process.env.REDIS_PORT, process.env.REDIS_HOST);

  sanitizer = require('sanitizer');

  redis.auth(process.env.REDIS_PASS);

  module.exports.Message = Message = (function() {

    Message.max_messages = 200;

    function Message(params) {
      var filter_author, filter_content;
      filter_content = function(content) {
        if (!(content != null) || content === '') {
          return '';
        }
        content = sanitizer.escape(content);
        return content.substr(0, 200);
      };
      filter_author = function(author) {
        if (!(author != null) || author === '') {
          return 'Anonymous';
        }
        return author.substr(0, 16);
      };
      if (params.id) {
        this.id = params.id;
      }
      this.content = filter_content(params.content);
      this.author_name = filter_author(params.author_name);
      this.author_ip = params.author_ip;
      this.color = params.color || null;
      this.image = params.image || '';
      this.server_event = params.server_event || '';
      this.sent_at = params.sent_at || null;
      this.persisted = false;
      return this;
    }

    Message.prototype.save = function(cb) {
      var _this = this;
      redis.incr('next_post_id', function(error, id) {
        var operation;
        if (error) {
          throw error;
        }
        if (!_this.id) {
          _this.id = id;
        }
        operation = redis.multi().set("Message:" + _this.id + ":content", _this.content).set("Message:" + _this.id + ":author_name", _this.author_name).set("Message:" + _this.id + ":author_ip", _this.author_ip).set("Message:" + _this.id + ":server_event", _this.server_event).set("Message:" + _this.id + ":image", _this.image).set("Message:" + _this.id + ":color", JSON.stringify(_this.color)).set("Message:" + _this.id + ":sent_at", new Date()).lpush('messages', _this.id);
        if (!_this.persisted) {
          operation.incr('message_count');
        }
        return operation.exec(function(error) {
          if (error) {
            throw error;
          }
          _this.persisted = true;
          return cb(error, _this.id);
        });
      });
      return this;
    };

    Message.prototype["delete"] = function(cb) {
      var _this = this;
      return redis.multi().del("Message:" + this.id + ":content").del("Message:" + this.id + ":author_name").del("Message:" + this.id + ":author_ip").del("Message:" + this.id + ":server_event").del("Message:" + this.id + ":image").del("Message:" + this.id + ":color").lrem('messages', 1, this.id).decr('message_count').exec(function(error) {
        if (error) {
          throw error;
        }
        _this.persisted = false;
        return cb(error, _this);
      });
    };

    Message["delete"] = function(id, cb) {
      var _this = this;
      return redis.multi().del("Message:" + id + ":content").del("Message:" + id + ":author_name").del("Message:" + id + ":author_ip").del("Message:" + id + ":server_event").del("Message:" + id + ":image").del("Message:" + id + ":color").lrem('messages', 1, id).decr('message_count').exec(function(error) {
        if (error) {
          throw error;
        }
        return cb(null, id);
      });
    };

    Message.get = function(id, cb) {
      var message;
      message = new Message({
        id: id
      });
      redis.multi().get("Message:" + id + ":content", function(error, result) {
        return message.content = result;
      }).get("Message:" + id + ":author_name", function(error, result) {
        return message.author_name = result;
      }).get("Message:" + id + ":author_ip", function(error, result) {
        return message.author_ip = result;
      }).get("Message:" + id + ":server_event", function(error, result) {
        return message.server_event = result;
      }).get("Message:" + id + ":image", function(error, result) {
        return message.image = result;
      }).get("Message:" + id + ":color", function(error, result) {
        return message.color = JSON.parse(result);
      }).get("Message:" + id + ":sent_at", function(error, result) {
        return message.sent_at = new Date(result);
      }).exec(function(error) {
        if (error) {
          throw error;
        }
        this.persisted = true;
        return cb(error, message);
      });
      return null;
    };

    Message.all = function(params, cb) {
      var messages,
        _this = this;
      params = params || {};
      messages = [];
      redis.lrange('messages', 0, Message.max_messages, function(error, results) {
        var completed, expected, id, idx, _i, _len, _results;
        if (error) {
          throw error;
        }
        if ((params.since != null) && (idx = results.indexOf(params.since + '')) !== -1) {
          results.splice(idx, results.length - idx + 1);
        }
        expected = results.length;
        completed = 0;
        _results = [];
        for (_i = 0, _len = results.length; _i < _len; _i++) {
          id = results[_i];
          _results.push(_this.get(id, function(error, message) {
            completed++;
            if (error) {
              throw error;
            }
            messages.push(message);
            if (completed >= expected) {
              return cb(null, messages);
            }
          }));
        }
        return _results;
      });
      return null;
    };

    Message.prune = function(cb) {
      redis.get('message_count', function(error, count) {
        var amount_to_remove;
        if (error) {
          return cb(error);
        }
        if (count <= Message.max_messages) {
          return cb(null, null);
        }
        amount_to_remove = count - Message.max_messages;
        return redis.lrange('messages', amount_to_remove * -1, -1, function(error, results) {
          var completed, expected, id, images_to_delete, _i, _len, _results;
          if (error) {
            return cb(error);
          }
          if (results.length === 0) {
            cb(error, null);
          }
          expected = results.length;
          completed = 0;
          images_to_delete = [];
          _results = [];
          for (_i = 0, _len = results.length; _i < _len; _i++) {
            id = results[_i];
            _results.push(Message.get(id, function(error, message) {
              if (error) {
                return cb(error);
              }
              if (message.image) {
                images_to_delete.push(message.image);
              }
              return message["delete"](function(error, id) {
                if (error) {
                  return cb(error);
                }
                completed++;
                if (completed >= expected) {
                  return cb(null, images_to_delete);
                }
              });
            }));
          }
          return _results;
        });
      });
      return null;
    };

    return Message;

  })();

}).call(this);
